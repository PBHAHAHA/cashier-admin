function M(t){return t.split("-")[1]}function J(t){return t==="y"?"height":"width"}function H(t){return t.split("-")[0]}function I(t){return["top","bottom"].includes(H(t))?"x":"y"}function U(t,e,n){let{reference:o,floating:i}=t;const c=o.x+o.width/2-i.width/2,s=o.y+o.height/2-i.height/2,r=I(e),l=J(r),a=o[l]/2-i[l]/2,d=H(e),f=r==="x";let u;switch(d){case"top":u={x:c,y:o.y-i.height};break;case"bottom":u={x:c,y:o.y+o.height};break;case"right":u={x:o.x+o.width,y:s};break;case"left":u={x:o.x-i.width,y:s};break;default:u={x:o.x,y:o.y}}switch(M(e)){case"start":u[r]-=a*(n&&f?-1:1);break;case"end":u[r]+=a*(n&&f?-1:1);break}return u}const lt=async(t,e,n)=>{const{placement:o="bottom",strategy:i="absolute",middleware:c=[],platform:s}=n,r=c.filter(Boolean),l=await(s.isRTL==null?void 0:s.isRTL(e));{if(s==null&&console.error(["Floating UI: `platform` property was not passed to config. If you","want to use Floating UI on the web, install @floating-ui/dom","instead of the /core package. Otherwise, you can create your own","`platform`: https://floating-ui.com/docs/platform"].join(" ")),r.filter(m=>{let{name:A}=m;return A==="autoPlacement"||A==="flip"}).length>1)throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware","detected. This will lead to an infinite loop. Ensure only one of","either has been passed to the `middleware` array."].join(" "));(!t||!e)&&console.error(["Floating UI: The reference and/or floating element was not defined","when `computePosition()` was called. Ensure that both elements have","been created and can be measured."].join(" "))}let a=await s.getElementRects({reference:t,floating:e,strategy:i}),{x:d,y:f}=U(a,o,l),u=o,h={},g=0;for(let m=0;m<r.length;m++){const{name:A,fn:w}=r[m],{x:p,y,data:O,reset:x}=await w({x:d,y:f,initialPlacement:o,placement:u,strategy:i,middlewareData:h,rects:a,platform:s,elements:{reference:t,floating:e}});if(d=p!=null?p:d,f=y!=null?y:f,h={...h,[A]:{...h[A],...O}},g>50&&console.warn(["Floating UI: The middleware lifecycle appears to be running in an","infinite loop. This is usually caused by a `reset` continually","being returned without a break condition."].join(" ")),x&&g<=50){g++,typeof x=="object"&&(x.placement&&(u=x.placement),x.rects&&(a=x.rects===!0?await s.getElementRects({reference:t,floating:e,strategy:i}):x.rects),{x:d,y:f}=U(a,u,l)),m=-1;continue}}return{x:d,y:f,placement:u,strategy:i,middlewareData:h}};function at(t){return{top:0,right:0,bottom:0,left:0,...t}}function ft(t){return typeof t!="number"?at(t):{top:t,right:t,bottom:t,left:t}}function X(t){return{...t,top:t.y,left:t.x,right:t.x+t.width,bottom:t.y+t.height}}const ut=Math.min,dt=Math.max;function ht(t,e,n){return dt(t,ut(e,n))}const Et=t=>({name:"arrow",options:t,async fn(e){const{element:n,padding:o=0}=t||{},{x:i,y:c,placement:s,rects:r,platform:l}=e;if(n==null)return console.warn("Floating UI: No `element` was passed to the `arrow` middleware."),{};const a=ft(o),d={x:i,y:c},f=I(s),u=J(f),h=await l.getDimensions(n),g=f==="y"?"top":"left",m=f==="y"?"bottom":"right",A=r.reference[u]+r.reference[f]-d[f]-r.floating[u],w=d[f]-r.reference[f],p=await(l.getOffsetParent==null?void 0:l.getOffsetParent(n));let y=p?f==="y"?p.clientHeight||0:p.clientWidth||0:0;y===0&&(y=r.floating[u]);const O=A/2-w/2,x=a[g],_=y-h[u]-a[m],E=y/2-h[u]/2+O,P=ht(x,E,_),ct=M(s)!=null&&E!=P&&r.reference[u]/2-(E<x?a[g]:a[m])-h[u]/2<0?E<x?x-E:_-E:0;return{[f]:d[f]-ct,data:{[f]:P,centerOffset:E-P}}}});async function gt(t,e){const{placement:n,platform:o,elements:i}=t,c=await(o.isRTL==null?void 0:o.isRTL(i.floating)),s=H(n),r=M(n),l=I(n)==="x",a=["left","top"].includes(s)?-1:1,d=c&&l?-1:1,f=typeof e=="function"?e(t):e;let{mainAxis:u,crossAxis:h,alignmentAxis:g}=typeof f=="number"?{mainAxis:f,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...f};return r&&typeof g=="number"&&(h=r==="end"?g*-1:g),l?{x:h*d,y:u*a}:{x:u*a,y:h*d}}const Ot=function(t){return t===void 0&&(t=0),{name:"offset",options:t,async fn(e){const{x:n,y:o}=e,i=await gt(e,t);return{x:n+i.x,y:o+i.y,data:i}}}};function b(t){var e;return((e=t.ownerDocument)==null?void 0:e.defaultView)||window}function v(t){return b(t).getComputedStyle(t)}function T(t){return Z(t)?(t.nodeName||"").toLowerCase():""}let V;function Q(){if(V)return V;const t=navigator.userAgentData;return t&&Array.isArray(t.brands)?(V=t.brands.map(e=>e.brand+"/"+e.version).join(" "),V):navigator.userAgent}function C(t){return t instanceof b(t).HTMLElement}function L(t){return t instanceof b(t).Element}function Z(t){return t instanceof b(t).Node}function Y(t){if(typeof ShadowRoot>"u")return!1;const e=b(t).ShadowRoot;return t instanceof e||t instanceof ShadowRoot}function W(t){const{overflow:e,overflowX:n,overflowY:o,display:i}=v(t);return/auto|scroll|overlay|hidden|clip/.test(e+o+n)&&!["inline","contents"].includes(i)}function pt(t){return["table","td","th"].includes(T(t))}function j(t){const e=/firefox/i.test(Q()),n=v(t),o=n.backdropFilter||n.WebkitBackdropFilter;return n.transform!=="none"||n.perspective!=="none"||(o?o!=="none":!1)||e&&n.willChange==="filter"||e&&(n.filter?n.filter!=="none":!1)||["transform","perspective"].some(i=>n.willChange.includes(i))||["paint","layout","strict","content"].some(i=>{const c=n.contain;return c!=null?c.includes(i):!1})}function tt(){return!/^((?!chrome|android).)*safari/i.test(Q())}function $(t){return["html","body","#document"].includes(T(t))}const z=Math.min,D=Math.max,S=Math.round;function et(t){const e=v(t);let n=parseFloat(e.width),o=parseFloat(e.height);const i=t.offsetWidth,c=t.offsetHeight,s=S(n)!==i||S(o)!==c;return s&&(n=i,o=c),{width:n,height:o,fallback:s}}function nt(t){return L(t)?t:t.contextElement}const ot={x:1,y:1};function F(t){const e=nt(t);if(!C(e))return ot;const n=e.getBoundingClientRect(),{width:o,height:i,fallback:c}=et(e);let s=(c?S(n.width):n.width)/o,r=(c?S(n.height):n.height)/i;return(!s||!Number.isFinite(s))&&(s=1),(!r||!Number.isFinite(r))&&(r=1),{x:s,y:r}}function k(t,e,n,o){var i,c;e===void 0&&(e=!1),n===void 0&&(n=!1);const s=t.getBoundingClientRect(),r=nt(t);let l=ot;e&&(o?L(o)&&(l=F(o)):l=F(t));const a=r?b(r):window,d=!tt()&&n;let f=(s.left+(d&&((i=a.visualViewport)==null?void 0:i.offsetLeft)||0))/l.x,u=(s.top+(d&&((c=a.visualViewport)==null?void 0:c.offsetTop)||0))/l.y,h=s.width/l.x,g=s.height/l.y;if(r){const m=b(r),A=o&&L(o)?b(o):o;let w=m.frameElement;for(;w&&o&&A!==m;){const p=F(w),y=w.getBoundingClientRect(),O=getComputedStyle(w);y.x+=(w.clientLeft+parseFloat(O.paddingLeft))*p.x,y.y+=(w.clientTop+parseFloat(O.paddingTop))*p.y,f*=p.x,u*=p.y,h*=p.x,g*=p.y,f+=y.x,u+=y.y,w=b(w).frameElement}}return{width:h,height:g,top:u,right:f+h,bottom:u+g,left:f,x:f,y:u}}function R(t){return((Z(t)?t.ownerDocument:t.document)||window.document).documentElement}function B(t){return L(t)?{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}:{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function it(t){return k(R(t)).left+B(t).scrollLeft}function mt(t,e,n){const o=C(e),i=R(e),c=k(t,!0,n==="fixed",e);let s={scrollLeft:0,scrollTop:0};const r={x:0,y:0};if(o||!o&&n!=="fixed")if((T(e)!=="body"||W(i))&&(s=B(e)),C(e)){const l=k(e,!0);r.x=l.x+e.clientLeft,r.y=l.y+e.clientTop}else i&&(r.x=it(i));return{x:c.left+s.scrollLeft-r.x,y:c.top+s.scrollTop-r.y,width:c.width,height:c.height}}function N(t){if(T(t)==="html")return t;const e=t.assignedSlot||t.parentNode||(Y(t)?t.host:null)||R(t);return Y(e)?e.host:e}function K(t){return!C(t)||v(t).position==="fixed"?null:t.offsetParent}function wt(t){let e=N(t);for(;C(e)&&!$(e);){if(j(e))return e;e=N(e)}return null}function q(t){const e=b(t);let n=K(t);for(;n&&pt(n)&&v(n).position==="static";)n=K(n);return n&&(T(n)==="html"||T(n)==="body"&&v(n).position==="static"&&!j(n))?e:n||wt(t)||e}function yt(t){return et(t)}function xt(t){let{rect:e,offsetParent:n,strategy:o}=t;const i=C(n),c=R(n);if(n===c)return e;let s={scrollLeft:0,scrollTop:0},r={x:1,y:1};const l={x:0,y:0};if((i||!i&&o!=="fixed")&&((T(n)!=="body"||W(c))&&(s=B(n)),C(n))){const a=k(n);r=F(n),l.x=a.x+n.clientLeft,l.y=a.y+n.clientTop}return{width:e.width*r.x,height:e.height*r.y,x:e.x*r.x-s.scrollLeft*r.x+l.x,y:e.y*r.y-s.scrollTop*r.y+l.y}}function bt(t,e){const n=b(t),o=R(t),i=n.visualViewport;let c=o.clientWidth,s=o.clientHeight,r=0,l=0;if(i){c=i.width,s=i.height;const a=tt();(a||!a&&e==="fixed")&&(r=i.offsetLeft,l=i.offsetTop)}return{width:c,height:s,x:r,y:l}}function vt(t){var e;const n=R(t),o=B(t),i=(e=t.ownerDocument)==null?void 0:e.body,c=D(n.scrollWidth,n.clientWidth,i?i.scrollWidth:0,i?i.clientWidth:0),s=D(n.scrollHeight,n.clientHeight,i?i.scrollHeight:0,i?i.clientHeight:0);let r=-o.scrollLeft+it(t);const l=-o.scrollTop;return v(i||n).direction==="rtl"&&(r+=D(n.clientWidth,i?i.clientWidth:0)-c),{width:c,height:s,x:r,y:l}}function rt(t){const e=N(t);return $(e)?t.ownerDocument.body:C(e)&&W(e)?e:rt(e)}function st(t,e){var n;e===void 0&&(e=[]);const o=rt(t),i=o===((n=t.ownerDocument)==null?void 0:n.body),c=b(o);return i?e.concat(c,c.visualViewport||[],W(o)?o:[]):e.concat(o,st(o))}function At(t,e){const n=k(t,!0,e==="fixed"),o=n.top+t.clientTop,i=n.left+t.clientLeft,c=C(t)?F(t):{x:1,y:1},s=t.clientWidth*c.x,r=t.clientHeight*c.y,l=i*c.x,a=o*c.y;return{top:a,left:l,right:l+s,bottom:a+r,x:l,y:a,width:s,height:r}}function G(t,e,n){return e==="viewport"?X(bt(t,n)):L(e)?At(e,n):X(vt(R(t)))}function Ct(t,e){const n=e.get(t);if(n)return n;let o=st(t).filter(r=>L(r)&&T(r)!=="body"),i=null;const c=v(t).position==="fixed";let s=c?N(t):t;for(;L(s)&&!$(s);){const r=v(s),l=j(s);(c?!l&&!i:!l&&r.position==="static"&&!!i&&["absolute","fixed"].includes(i.position))?o=o.filter(d=>d!==s):i=r,s=N(s)}return e.set(t,o),o}function Tt(t){let{element:e,boundary:n,rootBoundary:o,strategy:i}=t;const s=[...n==="clippingAncestors"?Ct(e,this._c):[].concat(n),o],r=s[0],l=s.reduce((a,d)=>{const f=G(e,d,i);return a.top=D(f.top,a.top),a.right=z(f.right,a.right),a.bottom=z(f.bottom,a.bottom),a.left=D(f.left,a.left),a},G(e,r,i));return{width:l.right-l.left,height:l.bottom-l.top,x:l.left,y:l.top}}const Lt={getClippingRect:Tt,convertOffsetParentRelativeRectToViewportRelativeRect:xt,isElement:L,getDimensions:yt,getOffsetParent:q,getDocumentElement:R,getScale:F,async getElementRects(t){let{reference:e,floating:n,strategy:o}=t;const i=this.getOffsetParent||q,c=this.getDimensions;return{reference:mt(e,await i(n),o),floating:{x:0,y:0,...await c(n)}}},getClientRects:t=>Array.from(t.getClientRects()),isRTL:t=>v(t).direction==="rtl"},Ft=(t,e,n)=>{const o=new Map,i={platform:Lt,...n},c={...i.platform,_c:o};return lt(t,e,{...i,platform:c})};export{Et as a,Ft as c,Ot as o};
